
객체, 배열

    - frontend

        1. 랜더링(화면에 그리는 것) 최적화
        2. 자주 바뀔 수 밖에 없는 화면에 유지 보수가 용이한 코드 작성
    

        데이터는 90% 가 객체, 배열로 이루어져있다.
        Json(Javascript Object Notation)

-------------------------------------------------

    객체
        키와 값으로 구성된 속성의 집합 -> 변수의 집단
        ex)
            let seongyong = {
                age: 20,
                height: 190
            }

            let post = {
                title: "안녕하세요",
                content: "반갑습니다",
                User: {
                    nickName: "스윗선아"
                },
                createAt: "2023-09-10",
                Commets: [
                    ...
                ]
            }

            => 하나의 공통된 주제로 여러가지의 값을 묶을 수 있다

            1. []표기법
                console.log(post["title"]) // 안녕하세요
                post["User"]["nickName"]

            2. . 표기법
                post.title // 안녕하세요
                post.User.nickName


-------------------------------------------------
    
    메서드 method

    const AuthService = {
        signIn() {
            
        },
        signUp(){

        },
        logOut(){

        },
    }

    ex) AuthService.자동완성
        AuthService.signIn()


-------------------------------------------------
    
    배열
        고차함수, 콜백함수
        (빌트 인 객체에 포함된 함수)

        자바스크립트의 배열은 가짜입니다.
        자바스크립트에서의 배열은 인덱스라는 키와
        해당 인덱스의 키에 값으로 구성된 객체를 말합니다.

        순서가 보장된 데이터들의 집단

        ex)
            const 와르르멘션 = ["짱구",{짱아,짱구네가족}, "오수", {남편,아내}, "옆집아줌마"]

            와르르멘션[0] //짱구
            와르르멘션[4] //옆집아줌마
            와르르멘션[2] = ""
            와르르멘션[2] // ""
                        // false 지만 비어있는 스트링과 nll undefined 은 다르다
            와르르멘션.splice(2) // 고차함수
            와르르멘션[2] // 남편, 아내

        * 객체와 배열의 가장 큰 차이점
            1. 객체는 순서가 없기 때문에 순회 반복이 불가능
               배열은 순서가 존재하기 때문에 순회 반복이 가능
            2.객체는 키 값이 중복되지 않습니다.
              그러나 배열은 인덱스 값이 키 값이 되어 0 부터 순차적으로 증가
              (인덱스 : 데이터가 여러개 있을 때 어떤 특정한 데이터를 구분 하여 쉽고 빠르게 값을 가져올 수 있도록 한다)

-------------------------------------------------

    배열의 내장함수와 고차함수

        내장함수 (원본배열, 복사본, 반환 값의 유무)
            push()
                ()안의 데이터를 원본 배열의 맨 끝 요소(el)로 추가

            pop()
                원본 배열의 맨 끝 요소를 제거, 제거된 요소를 반환

                ex)
                    const arr = [1,2,3,4]
                    const a = arr.pop()
                    console.log(arr) // [1,2,3]
                    console.log(a) //4

            unshift()
                ()안의 데이터를 원본 배열의 맨 앞에 추가

            shift
                원본 배열의 맨 앞에 요소를 제거, 제거된 요소를 반환

            concat(arr1, arr2)
                ()안의 두 배열을 합친 하나의 복사본 배열을 반환

                arr1 = [1,2,3,4,5] arr2=[1,2,3,4]
                [1,2,3,4,5,1,2,3,4]

            join
                배열 요소 사이에 원하는 문자를 삽입한 문자열을 반환
                ex) [1,2,3,4,5].join("-") => "1-2-3-4-5"
                    [1,2,3,4,5].join() => "12345"
                    ["<div>", ... ].join() => "<div></div>
                                               <div></div>"

            reverse
                원본 배열 역순 배치
                ex)
                    [1,2,3,4,5] -> [5,4,3,2,1]

            splice(start, count, item)
                - start부터 시작하는 인덱스 번호부터 count만큼 원본 배열에 요소를 제거
                - 제거한 부분에 item을 대체할 수 있음
                - 배열의 특정 부분을 제거

                const arr = [1,2,3,4,5,6,7]
                arr.splice(3,3,"hello")
                (1, 2, 3, hello, 7)

            slice(start, end)
                - 원본 배열의 데이터를 삭제하지는 않으나, start부터 end 직전까지(포함x)
                - 잘라서 복사본으로 반환
                - 배열의 특정 부분을 복사

            indexOf
            includes

        고차함수 ()
            map
            filter
            find
            findIndex
            reduce
            every
            some
            sort

            














